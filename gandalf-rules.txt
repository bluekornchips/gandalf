---
description: 
globs: 
alwaysApply: true
---
# Gandalf MCP Rules

**Core Principle:** Gather context before making changes. Store conversations first and last for complete session preservation.

## CRITICAL: Conversation Storage Protocol

**REQUIRED WORKFLOW:**
1. **FIRST ACTION**: When receiving a user message, immediately call `store_conversation` to preserve the user's request
2. **WORK PHASE**: Use MCP tools to gather context and complete the requested work
3. **FINAL ACTION**: After completing all work, call `store_conversation` again to preserve the complete session including your response

**Why This Matters:**
- Preserves valuable debugging sessions and architectural decisions
- Enables future reference and learning from past conversations
- Maintains context across sessions for better assistance
- Creates searchable knowledge base of solutions and patterns

## When to Use MCP Tools

**Always use for:**
- Understanding unfamiliar codebases or projects
- Complex refactoring or architectural changes
- Debugging issues without clear root cause
- Building on previous work or established patterns

**Use when helpful:**
- Writing documentation or explanations
- Making decisions that affect multiple files/components
- Reviewing or validating approach before implementation

**Never execute, unless explicitly told to do so by the user:**
- git commands that alter state
- commands that alter files outside of the project root

## Context Gathering Strategy

### Phase 1: Project Overview
1. **Start with project state:** `get_project_info` for metadata, git status, and statistics
2. **Understand file structure:** `list_project_files` with relevance scoring enabled
   - Use file type filtering (e.g., `['.py', '.js']`) when working on specific languages
   - Enable `use_relevance_scoring: true` for intelligent prioritization
   - Adjust `max_files` based on project size (20-50 for focused work, 100+ for exploration)

### Phase 2: Historical Context
3. **Check previous work:** `list_conversations` to find related past sessions
4. **Get detailed context:** `get_conversation_context` for specific insights
   - Use `type: "analytics"` for tool usage patterns and debugging MCP issues
   - Use `type: "real"` for actual user-assistant conversations and solutions
   - Set `include_messages: true` when you need full conversation details

### Phase 3: Deep Dive
5. **Search conversations:** `search_conversations` with specific queries for relevant past work
6. **Get conversation summaries:** `get_conversation_summary` for detailed context of specific sessions
7. **Analyze conversation types:** Distinguish between real conversations (valuable dialogue) and analytics (tool usage tracking)

## Enhanced Conversation Management

### Conversation Storage Guidelines

**When to Store (First Action):**
- Every user message that contains a request or question
- Complex problem-solving sessions that span multiple messages
- Architectural decisions and design discussions
- Debugging sessions with valuable insights or solutions
- Learning conversations that establish patterns or best practices

**Storage Best Practices:**
1. **Immediate Storage**: Store user messages when they contain significant context or requests
2. **Complete Sessions**: Store full conversations including assistant responses after resolution
3. **Rich Metadata**: Include current file context, git branch, and cursor position when available
4. **Descriptive Titles**: Use meaningful titles that describe the problem or topic
5. **Strategic Tags**: Add relevant tags for categorization (e.g., "debugging", "refactoring", "architecture")

**Example Storage Workflow:**
```
User: "Help me debug this performance issue in my React component"

1. FIRST: store_conversation(user_message)
2. get_project_info() to understand project context
3. list_project_files(file_types=['.js', '.jsx', '.ts', '.tsx'])
4. search_conversations(query="React performance")
5. [Complete the debugging work]
6. LAST: store_conversation(complete_session_with_solution)
```

### Conversation Types and Analytics

**Real Conversations:**
- Actual user-assistant dialogue with meaningful problem-solving content
- Store manually using `store_conversation` tool for important sessions
- Include descriptive titles, relevant tags, and file context metadata
- Focus on preserving valuable debugging, architectural, or learning conversations

**Analytics Sessions:**
- Automatic tool usage tracking (session metadata and tool execution logs)
- Generated automatically every 2 tool calls via auto-session manager
- Linked to conversation sessions for traceability
- Useful for understanding tool usage patterns and debugging MCP activity

## File Operations Best Practices

**Use `list_project_files` for:**
- Understanding project structure and architecture
- Finding relevant files before making changes
- Discovering patterns and conventions
- Identifying configuration files, tests, documentation

**Key parameters:**
- `file_types`: Filter by extensions (e.g., `['.py', '.md', '.json']`)
- `use_relevance_scoring: true`: Get intelligent prioritization
- `max_files`: Start with 50, increase if needed

**Example usage patterns:**
```
# Understand Python project structure
list_project_files(file_types=['.py'], max_files=50, use_relevance_scoring=true)

# Find all configuration files
list_project_files(file_types=['.json', '.yaml', '.toml', '.ini'], max_files=30)

# Get full project overview
list_project_files(max_files=100, use_relevance_scoring=true)
```

## Available Tools

### Project & File Operations
- `get_project_info` - Project metadata, Git info, and file statistics (fast shell-based)
- `list_project_files` - Discover project structure with intelligent prioritization

### Enhanced Conversation Management
- `store_conversation` - **CRITICAL**: Save sessions for future reference (use first and last)
- `get_conversation_context` - Recent conversation history for continuity
- `list_conversations` - Find past relevant sessions with enhanced timestamp display
- `search_conversations` - Search by content, title, or tags with improved results
- `get_conversation_summary` - Detailed summary of specific conversations with type detection
- `add_message` - Add messages to current conversation session

## Priority Order

1. **FIRST**: `store_conversation` to preserve user request
2. **Project overview**: `get_project_info` for basic context
3. **File structure**: `list_project_files` with intelligent scoring
4. **Historical context**: `list_conversations` and `get_conversation_context`
5. **Targeted search**: `search_conversations` for specific past work or solutions
6. **Deep research**: `get_conversation_summary` for detailed context of relevant sessions
7. **[Complete the requested work]**
8. **LAST**: `store_conversation` to preserve complete session with solution

## Context Intelligence

- File operations use intelligent relevance scoring by default
- High/medium/low priority files are automatically identified
- Context intelligence adapts to project patterns and recent changes
- Enhanced conversation management distinguishes between valuable dialogue and tool usage analytics

## Auto-Session Management

**REQUIRED:** Every assistant message must end with at least one MCP tool call to ensure auto-session functionality works properly. The final call should typically be `store_conversation` to preserve the complete session.

**Default end-of-message tool calls:**
- `store_conversation` - **PREFERRED**: Store complete session with solution
- `get_project_info` - For general status and project context
- `list_conversations` - When conversation history might be relevant
- `get_conversation_context` - For continuity in ongoing work

**Purpose:** This ensures the auto-session manager records tool usage and triggers automatic conversation storage at the configured threshold, preserving context across sessions.

**Dual System Benefits:**
- **Analytics Sessions:** Automatic tool usage tracking for debugging and performance analysis
- **Real Conversations:** Manual preservation of actual user-assistant dialogue for context and reference
- **Enhanced CLI:** Improved conversation management with better display, search, and retrieval capabilities

Both systems work together with enhanced tooling to provide complete visibility into MCP activity, preserve valuable conversations, and enable effective context management across sessions.

## Summary Workflow

```
1. User sends message
2. IMMEDIATELY: store_conversation(user_message) 
3. Gather context with MCP tools as needed
4. Complete the requested work
5. FINALLY: store_conversation(complete_session)
```

This ensures every valuable interaction is preserved for future reference and learning.
